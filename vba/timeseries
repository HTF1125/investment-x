Option Explicit

Private Const SHEET_NAME As String = "Timeseries"
Private Const TABLE_NAME As String = "Timeseries"
Private Const endpoint As String = "api/timeseries"

' Only update these fields from API response
Private Function AllowedUpdateColumns() As Object
    Dim d As Object
    Set d = CreateObject("Scripting.Dictionary")
    d.CompareMode = vbTextCompare
    d.Add "id", True
    d.Add "code", True
    d.Add "name", True
    d.Add "provider", True
    d.Add "frequency", True
    d.Add "source", True
    d.Add "source_code", True
    d.Add "country", True
    d.Add "currency", True
    d.Add "scale", True
    d.Add "unit", True
    d.Add "remark", True
    d.Add "asset_class", True
    d.Add "category", True
    Set AllowedUpdateColumns = d
End Function

' ============================
' ENTRY POINT
' ============================
Public Sub PushTimeseries()
    On Error GoTo ErrHandler

    Dim ws As Worksheet, lo As ListObject
    Dim payload As String, status As Long, responseText As String
    Dim rows As Collection

    Set ws = ThisWorkbook.Worksheets(SHEET_NAME)
    Set lo = ws.ListObjects(TABLE_NAME)

    Set rows = GetSelectedRows(lo)
    If rows.count = 0 Then
        MsgBox "No valid rows selected (need at least a code).", vbExclamation
        Exit Sub
    End If

    ' Single-row path: use new RESTful endpoints (POST /timeseries/{code}, fallback PUT)
    If rows.count = 1 Then
        Dim r As Long
        r = CLng(rows(1))

        Dim codeCol As Long
        codeCol = lo.ListColumns("code").index
        Dim codeVal As String
        codeVal = SafeCell(lo, r, codeCol)
        If Len(codeVal) = 0 Then
            MsgBox "Selected row has no code.", vbExclamation
            Exit Sub
        End If

        Dim rowJson As String
        rowJson = BuildRowJson(lo, r)
        If Len(rowJson) = 0 Then
            MsgBox "Nothing to send for selected row.", vbExclamation
            Exit Sub
        End If

        Dim url As String
        url = ApiBase() & endpoint & "/" & EscapePath(codeVal)

        ' First try create (201 on success)
        SendJson "POST", url, rowJson, status, responseText
        If status = 409 Then
            ' Already exists -> update in place
            SendJson "PUT", url, rowJson, status, responseText
        End If

        If status >= 200 And status < 300 Then
            UpdateSingleRowFromResponse lo, r, responseText
            MsgBox "? Sent successfully (single create/update).", vbInformation
        Else
            MsgBox "? API error " & status & vbCrLf & responseText, vbCritical
        End If
        Exit Sub
    End If

    ' Multi-row path: keep bulk POST behavior
    payload = BuildPayloadFromRows(lo, rows)
    If payload = "" Then
        MsgBox "No valid rows selected (need at least a code).", vbExclamation
        Exit Sub
    End If

    PostJson payload, status, responseText

    If status >= 200 And status < 300 Then
        UpdateAllowedFieldsFromResponse lo, responseText
        MsgBox "? Sent successfully (create/update).", vbInformation
    ElseIf status = 422 Then
        Dim pos As Long
        pos = ExtractErrorPositionFromResponse(responseText)
        If pos > 0 Then
            MsgBox "? JSON decode error at position " & pos & vbCrLf & _
                   GetPayloadSnippet(payload, pos, 80) & vbCrLf & vbCrLf & _
                   "Server response:" & vbCrLf & responseText, vbCritical
        Else
            MsgBox "? API 422. Response:" & vbCrLf & responseText, vbCritical
        End If
    Else
        MsgBox "? API error " & status & vbCrLf & responseText, vbCritical
    End If

    Exit Sub

ErrHandler:
    MsgBox "VBA error: " & Err.Description, vbCritical
End Sub

' ============================
' BUILD PAYLOAD
' - Array of JSON objects
' - Row included if it has code
' - id key is included only if non-empty
' - empty values are skipped (no "" keys)
' ============================
Private Function BuildPayloadFromRows(lo As ListObject, rows As Collection) As String
    Dim jsonItems() As String
    Dim count As Long
    count = 0
    ReDim jsonItems(1 To rows.count)

    Dim i As Long
    For i = 1 To rows.count
        Dim rowJson As String
        rowJson = BuildRowJson(lo, CLng(rows(i)))
        If rowJson <> "" Then
            count = count + 1
            jsonItems(count) = rowJson
        End If
    Next i

    If count = 0 Then
        BuildPayloadFromRows = ""
        Exit Function
    End If

    ReDim Preserve jsonItems(1 To count)
    BuildPayloadFromRows = "[" & Join(jsonItems, ",") & "]"
End Function

Private Function BuildRowJson(lo As ListObject, ByVal r As Long) As String
    Dim codeCol As Long
    codeCol = lo.ListColumns("code").index

    Dim codeVal As String
    codeVal = SafeCell(lo, r, codeCol)

    ' Must have code for both create and update
    If Len(codeVal) = 0 Then
        BuildRowJson = ""
        Exit Function
    End If

    Dim parts() As String
    Dim n As Long
    n = 0
    ReDim parts(1 To lo.ListColumns.count)

    Dim c As Long
    For c = 1 To lo.ListColumns.count
        Dim colName As String
        colName = lo.ListColumns(c).Name

        Dim v As String
        v = SafeCell(lo, r, c)

        ' Skip empty fields
        If Len(v) = 0 Then GoTo NextCol

        ' For create: don't send id if blank (already handled by Len(v)=0)
        ' For update: id will be sent if present

        n = n + 1
        parts(n) = """" & EscapeJson(colName) & """:""" & EscapeJson(v) & """"

NextCol:
    Next c

    If n = 0 Then
        BuildRowJson = ""
        Exit Function
    End If

    ReDim Preserve parts(1 To n)
    BuildRowJson = "{" & Join(parts, ",") & "}"
End Function

' ============================
' SAFE CELL READ (prevents type mismatch)
' ============================
Private Function SafeCell(lo As ListObject, ByVal r As Long, ByVal c As Long) As String
    Dim v As Variant
    v = lo.DataBodyRange.Cells(r, c).value

    If IsError(v) Then
        SafeCell = ""
    ElseIf IsEmpty(v) Then
        SafeCell = ""
    Else
        SafeCell = Trim$(CStr(v))
    End If
End Function

' ============================
' HTTP POST
' ============================
Private Sub PostJson(ByVal payload As String, ByRef status As Long, ByRef responseText As String)
    SendJson "POST", ApiBase() & endpoint, payload, status, responseText
End Sub

Private Sub SendJson(ByVal method As String, ByVal url As String, ByVal payload As String, ByRef status As Long, ByRef responseText As String)
    Dim http As Object
    Set http = CreateObject("WinHttp.WinHttpRequest.5.1")

    http.Open method, url, False
    http.setRequestHeader "Content-Type", "application/json; charset=utf-8"
    http.Send payload

    status = http.status
    responseText = http.responseText
End Sub

Private Function ApiBase() As String
    Dim baseUrl As String
    baseUrl = Trim$(CStr(ThisWorkbook.Names("API_URL").RefersToRange.value))
    If Right$(baseUrl, 1) <> "/" Then baseUrl = baseUrl & "/"
    ApiBase = baseUrl
End Function

' ============================
' UPDATE SHEET FROM RESPONSE
' - No JSON parser; simple scanning per object
' - For each object: find code, then update allowed fields found in that object
' ============================
Private Sub UpdateAllowedFieldsFromResponse(lo As ListObject, ByVal responseText As String)
    Dim s As String
    s = Trim$(responseText)
    If Len(s) = 0 Then Exit Sub

    Dim allowed As Object
    Set allowed = AllowedUpdateColumns()

    Dim headerMap As Object
    Set headerMap = CreateObject("Scripting.Dictionary")
    headerMap.CompareMode = vbTextCompare

    Dim lc As ListColumn
    For Each lc In lo.ListColumns
        headerMap(lc.Name) = lc.index
    Next lc

    If Not headerMap.Exists("code") Then Exit Sub

    Dim objects As Collection
    Set objects = ExtractTopLevelObjects(s)
    If objects.count = 0 Then Exit Sub

    Dim i As Long
    For i = 1 To objects.count
        Dim obj As String
        obj = objects(i)

        Dim codeVal As String
        codeVal = ExtractStringField(obj, "code")
        If Len(codeVal) = 0 Then GoTo NextObj

        Dim rowIndex As Long
        rowIndex = FindRowByCode(lo, codeVal)
        If rowIndex <= 0 Then GoTo NextObj

        Dim k As Variant
        For Each k In allowed.keys
            Dim fieldName As String
            fieldName = CStr(k)

            If headerMap.Exists(fieldName) Then
                Dim fieldVal As String

                ' id might be string UUID or numeric; handle both
                If LCase$(fieldName) = "id" Then
                    fieldVal = ExtractAnyField(obj, "id")
                Else
                    fieldVal = ExtractAnyField(obj, fieldName)
                End If

                If Len(fieldVal) > 0 Then
                    lo.DataBodyRange.Cells(rowIndex, headerMap(fieldName)).value = fieldVal
                End If
            End If
        Next k

NextObj:
    Next i
End Sub

Private Sub UpdateSingleRowFromResponse(lo As ListObject, ByVal rowIndex As Long, ByVal responseText As String)
    Dim s As String
    s = Trim$(responseText)
    If Len(s) = 0 Then Exit Sub

    Dim objects As Collection
    Set objects = ExtractTopLevelObjects(s)

    If objects.count > 0 Then
        UpdateRowFromObject lo, rowIndex, CStr(objects(1))
    ElseIf Left$(s, 1) = "{" And Right$(s, 1) = "}" Then
        UpdateRowFromObject lo, rowIndex, s
    End If
End Sub

Private Sub UpdateRowFromObject(lo As ListObject, ByVal rowIndex As Long, ByVal obj As String)
    Dim allowed As Object
    Set allowed = AllowedUpdateColumns()

    Dim headerMap As Object
    Set headerMap = CreateObject("Scripting.Dictionary")
    headerMap.CompareMode = vbTextCompare

    Dim lc As ListColumn
    For Each lc In lo.ListColumns
        headerMap(lc.Name) = lc.index
    Next lc

    Dim k As Variant
    For Each k In allowed.keys
        Dim fieldName As String
        fieldName = CStr(k)
        If headerMap.Exists(fieldName) Then
            Dim fieldVal As String
            If LCase$(fieldName) = "id" Then
                fieldVal = ExtractAnyField(obj, "id")
            Else
                fieldVal = ExtractAnyField(obj, fieldName)
            End If
            If Len(fieldVal) > 0 Then
                lo.DataBodyRange.Cells(rowIndex, headerMap(fieldName)).value = fieldVal
            End If
        End If
    Next k
End Sub

Private Function FindRowByCode(lo As ListObject, ByVal codeValue As String) As Long
    Dim codeCol As Long
    codeCol = lo.ListColumns("code").index

    Dim r As Long
    For r = 1 To lo.DataBodyRange.rows.count
        If SafeCell(lo, r, codeCol) = codeValue Then
            FindRowByCode = r
            Exit Function
        End If
    Next r
    FindRowByCode = 0
End Function

' ============================
' RESPONSE OBJECT EXTRACTION (no regex)
' - If response is { ... } -> one object
' - If response is [ { ... }, { ... } ] -> extract top-level objects
' ============================
Private Function ExtractTopLevelObjects(ByVal jsonText As String) As Collection
    Dim col As New Collection
    Dim s As String
    s = Trim$(jsonText)

    If Len(s) = 0 Then
        Set ExtractTopLevelObjects = col
        Exit Function
    End If

    If Left$(s, 1) = "{" Then
        col.Add s
        Set ExtractTopLevelObjects = col
        Exit Function
    End If

    If Left$(s, 1) <> "[" Then
        Set ExtractTopLevelObjects = col
        Exit Function
    End If

    Dim i As Long
    Dim ch As String
    Dim depth As Long
    Dim inQuotes As Boolean
    Dim esc As Boolean
    Dim cur As String

    depth = 0: inQuotes = False: esc = False: cur = ""

    For i = 1 To Len(s)
        ch = Mid$(s, i, 1)

        If ch = "\" Then
            esc = Not esc
            If depth > 0 Then cur = cur & ch
        ElseIf ch = """" And Not esc Then
            inQuotes = Not inQuotes
            If depth > 0 Then cur = cur & ch
            esc = False
        ElseIf inQuotes Then
            If depth > 0 Then cur = cur & ch
            esc = False
        Else
            If ch = "{" Then
                depth = depth + 1
                cur = cur & ch
            ElseIf ch = "}" Then
                cur = cur & ch
                depth = depth - 1
                If depth = 0 Then
                    col.Add cur
                    cur = ""
                End If
            Else
                If depth > 0 Then cur = cur & ch
            End If
            esc = False
        End If
    Next i

    Set ExtractTopLevelObjects = col
End Function

' ============================
' FIELD EXTRACTORS (no regex)
' ExtractStringField: expects "key":"value"
' ExtractAnyField: supports "key":"value" OR "key":123 OR "key":null
' ============================
Private Function ExtractStringField(ByVal obj As String, ByVal key As String) As String
    Dim pat As String
    pat = """" & key & """:"""
    Dim p As Long
    p = InStr(1, obj, pat, vbTextCompare)
    If p = 0 Then Exit Function

    Dim startPos As Long
    startPos = p + Len(pat)

    Dim i As Long
    For i = startPos To Len(obj)
        Dim ch As String
        ch = Mid$(obj, i, 1)
        If ch = """" Then
            ExtractStringField = Mid$(obj, startPos, i - startPos)
            Exit Function
        End If
    Next i
End Function

Private Function ExtractAnyField(ByVal obj As String, ByVal key As String) As String
    Dim pat As String
    pat = """" & key & """:"
    Dim p As Long
    p = InStr(1, obj, pat, vbTextCompare)
    If p = 0 Then Exit Function

    Dim i As Long
    i = p + Len(pat)

    ' Skip spaces
    Do While i <= Len(obj) And Mid$(obj, i, 1) = " "
        i = i + 1
    Loop

    If i > Len(obj) Then Exit Function

    Dim ch As String
    ch = Mid$(obj, i, 1)

    ' Quoted string
    If ch = """" Then
        ExtractAnyField = ExtractStringField(obj, key)
        Exit Function
    End If

    ' null
    If LCase$(Mid$(obj, i, 4)) = "null" Then
        ExtractAnyField = ""
        Exit Function
    End If

    ' number / token until comma or }
    Dim startPos As Long
    startPos = i

    Do While i <= Len(obj)
        ch = Mid$(obj, i, 1)
        If ch = "," Or ch = "}" Or ch = "]" Then Exit Do
        i = i + 1
    Loop

    ExtractAnyField = Trim$(Mid$(obj, startPos, i - startPos))
End Function

' ============================
' ERROR POSITION FROM 422 RESPONSE (no regex)
' Looks for ["body",342]
' ============================
Private Function ExtractErrorPositionFromResponse(ByVal resp As String) As Long
    Dim p As Long
    p = InStr(1, resp, "[""body"",", vbTextCompare)
    If p = 0 Then
        ExtractErrorPositionFromResponse = 0
        Exit Function
    End If

    Dim i As Long
    i = p + Len("[""body"",")

    ' Skip spaces
    Do While i <= Len(resp) And Mid$(resp, i, 1) = " "
        i = i + 1
    Loop

    Dim numText As String
    numText = ""

    Do While i <= Len(resp)
        Dim ch As String
        ch = Mid$(resp, i, 1)
        If ch < "0" Or ch > "9" Then Exit Do
        numText = numText & ch
        i = i + 1
    Loop

    If Len(numText) > 0 Then
        ExtractErrorPositionFromResponse = CLng(numText)
    Else
        ExtractErrorPositionFromResponse = 0
    End If
End Function

Private Function GetPayloadSnippet(ByVal payload As String, ByVal pos As Long, ByVal contextLen As Long) As String
    Dim n As Long
    n = Len(payload)
    If n = 0 Or pos <= 0 Then
        GetPayloadSnippet = ""
        Exit Function
    End If

    Dim startPos As Long, endPos As Long
    startPos = pos - contextLen
    If startPos < 1 Then startPos = 1
    endPos = pos + contextLen
    If endPos > n Then endPos = n

    GetPayloadSnippet = Mid$(payload, startPos, endPos - startPos + 1)
End Function

' ============================
' JSON escaping
' ============================
Private Function EscapeJson(ByVal s As String) As String
    s = Replace(s, "\", "\\")
    s = Replace(s, """", "\""")
    s = Replace(s, vbCrLf, "\n")
    s = Replace(s, vbCr, "\n")
    s = Replace(s, vbLf, "\n")
    EscapeJson = s
End Function

Private Function EscapePath(ByVal s As String) As String
    ' Minimal URL encoding for path segments (no full RFC coverage)
    s = Replace(s, "%", "%25")
    s = Replace(s, " ", "%20")
    s = Replace(s, "/", "%2F")
    s = Replace(s, "#", "%23")
    s = Replace(s, "?", "%3F")
    s = Replace(s, "&", "%26")
    s = Replace(s, "=", "%3D")
    EscapePath = s
End Function

' ============================
' Selected rows in the table
' ============================
Private Function GetSelectedRows(lo As ListObject) As Collection
    Dim result As New Collection
    Dim c As Range
    Dim rowIndex As Long

    For Each c In Selection.Cells
        If Not Intersect(c, lo.DataBodyRange) Is Nothing Then
            rowIndex = c.Row - lo.DataBodyRange.Row + 1
            On Error Resume Next
            result.Add rowIndex, CStr(rowIndex) ' unique
            On Error GoTo 0
        End If
    Next c

    Set GetSelectedRows = result
End Function


